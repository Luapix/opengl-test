// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERIALIZER_PIXCRAFT_SERIALIZER_H_
#define FLATBUFFERS_GENERATED_SERIALIZER_PIXCRAFT_SERIALIZER_H_

#include "flatbuffers/flatbuffers.h"

namespace PixCraft {
namespace Serializer {

struct Vec3;

struct MobBase;

struct Player;

struct Slime;

struct Chunk;

struct World;

enum BlockType {
  BlockType_Air = 0,
  BlockType_Stone = 1,
  BlockType_Dirt = 2,
  BlockType_Grass = 3,
  BlockType_Trunk = 4,
  BlockType_Leaves = 5,
  BlockType_Water = 6,
  BlockType_Planks = 7,
  BlockType_MIN = BlockType_Air,
  BlockType_MAX = BlockType_Planks
};

inline const BlockType (&EnumValuesBlockType())[8] {
  static const BlockType values[] = {
    BlockType_Air,
    BlockType_Stone,
    BlockType_Dirt,
    BlockType_Grass,
    BlockType_Trunk,
    BlockType_Leaves,
    BlockType_Water,
    BlockType_Planks
  };
  return values;
}

inline const char * const *EnumNamesBlockType() {
  static const char * const names[9] = {
    "Air",
    "Stone",
    "Dirt",
    "Grass",
    "Trunk",
    "Leaves",
    "Water",
    "Planks",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlockType(BlockType e) {
  if (e < BlockType_Air || e > BlockType_Planks) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlockType()[index];
}

enum MovementMode {
  MovementMode_Normal = 0,
  MovementMode_Flying = 1,
  MovementMode_NoClip = 2,
  MovementMode_MIN = MovementMode_Normal,
  MovementMode_MAX = MovementMode_NoClip
};

inline const MovementMode (&EnumValuesMovementMode())[3] {
  static const MovementMode values[] = {
    MovementMode_Normal,
    MovementMode_Flying,
    MovementMode_NoClip
  };
  return values;
}

inline const char * const *EnumNamesMovementMode() {
  static const char * const names[4] = {
    "Normal",
    "Flying",
    "NoClip",
    nullptr
  };
  return names;
}

inline const char *EnumNameMovementMode(MovementMode e) {
  if (e < MovementMode_Normal || e > MovementMode_NoClip) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMovementMode()[index];
}

enum Mob {
  Mob_NONE = 0,
  Mob_Player = 1,
  Mob_Slime = 2,
  Mob_MIN = Mob_NONE,
  Mob_MAX = Mob_Slime
};

inline const Mob (&EnumValuesMob())[3] {
  static const Mob values[] = {
    Mob_NONE,
    Mob_Player,
    Mob_Slime
  };
  return values;
}

inline const char * const *EnumNamesMob() {
  static const char * const names[4] = {
    "NONE",
    "Player",
    "Slime",
    nullptr
  };
  return names;
}

inline const char *EnumNameMob(Mob e) {
  if (e < Mob_NONE || e > Mob_Slime) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMob()[index];
}

template<typename T> struct MobTraits {
  static const Mob enum_value = Mob_NONE;
};

template<> struct MobTraits<PixCraft::Serializer::Player> {
  static const Mob enum_value = Mob_Player;
};

template<> struct MobTraits<PixCraft::Serializer::Slime> {
  static const Mob enum_value = Mob_Slime;
};

bool VerifyMob(flatbuffers::Verifier &verifier, const void *obj, Mob type);
bool VerifyMobVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

struct MobBase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ORIENT = 6,
    VT_SPEED = 8
  };
  const PixCraft::Serializer::Vec3 *pos() const {
    return GetStruct<const PixCraft::Serializer::Vec3 *>(VT_POS);
  }
  const PixCraft::Serializer::Vec3 *orient() const {
    return GetStruct<const PixCraft::Serializer::Vec3 *>(VT_ORIENT);
  }
  const PixCraft::Serializer::Vec3 *speed() const {
    return GetStruct<const PixCraft::Serializer::Vec3 *>(VT_SPEED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<PixCraft::Serializer::Vec3>(verifier, VT_POS) &&
           VerifyField<PixCraft::Serializer::Vec3>(verifier, VT_ORIENT) &&
           VerifyField<PixCraft::Serializer::Vec3>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
};

struct MobBaseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const PixCraft::Serializer::Vec3 *pos) {
    fbb_.AddStruct(MobBase::VT_POS, pos);
  }
  void add_orient(const PixCraft::Serializer::Vec3 *orient) {
    fbb_.AddStruct(MobBase::VT_ORIENT, orient);
  }
  void add_speed(const PixCraft::Serializer::Vec3 *speed) {
    fbb_.AddStruct(MobBase::VT_SPEED, speed);
  }
  explicit MobBaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MobBaseBuilder &operator=(const MobBaseBuilder &);
  flatbuffers::Offset<MobBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MobBase>(end);
    return o;
  }
};

inline flatbuffers::Offset<MobBase> CreateMobBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    const PixCraft::Serializer::Vec3 *pos = 0,
    const PixCraft::Serializer::Vec3 *orient = 0,
    const PixCraft::Serializer::Vec3 *speed = 0) {
  MobBaseBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_orient(orient);
  builder_.add_pos(pos);
  return builder_.Finish();
}

struct Player FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOB = 4,
    VT_MOVEMENT_MODE = 6
  };
  const PixCraft::Serializer::MobBase *mob() const {
    return GetPointer<const PixCraft::Serializer::MobBase *>(VT_MOB);
  }
  PixCraft::Serializer::MovementMode movement_mode() const {
    return static_cast<PixCraft::Serializer::MovementMode>(GetField<uint8_t>(VT_MOVEMENT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOB) &&
           verifier.VerifyTable(mob()) &&
           VerifyField<uint8_t>(verifier, VT_MOVEMENT_MODE) &&
           verifier.EndTable();
  }
};

struct PlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mob(flatbuffers::Offset<PixCraft::Serializer::MobBase> mob) {
    fbb_.AddOffset(Player::VT_MOB, mob);
  }
  void add_movement_mode(PixCraft::Serializer::MovementMode movement_mode) {
    fbb_.AddElement<uint8_t>(Player::VT_MOVEMENT_MODE, static_cast<uint8_t>(movement_mode), 0);
  }
  explicit PlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerBuilder &operator=(const PlayerBuilder &);
  flatbuffers::Offset<Player> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Player>(end);
    return o;
  }
};

inline flatbuffers::Offset<Player> CreatePlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PixCraft::Serializer::MobBase> mob = 0,
    PixCraft::Serializer::MovementMode movement_mode = PixCraft::Serializer::MovementMode_Normal) {
  PlayerBuilder builder_(_fbb);
  builder_.add_mob(mob);
  builder_.add_movement_mode(movement_mode);
  return builder_.Finish();
}

struct Slime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MOB = 4
  };
  const PixCraft::Serializer::MobBase *mob() const {
    return GetPointer<const PixCraft::Serializer::MobBase *>(VT_MOB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOB) &&
           verifier.VerifyTable(mob()) &&
           verifier.EndTable();
  }
};

struct SlimeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mob(flatbuffers::Offset<PixCraft::Serializer::MobBase> mob) {
    fbb_.AddOffset(Slime::VT_MOB, mob);
  }
  explicit SlimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SlimeBuilder &operator=(const SlimeBuilder &);
  flatbuffers::Offset<Slime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slime>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slime> CreateSlime(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PixCraft::Serializer::MobBase> mob = 0) {
  SlimeBuilder builder_(_fbb);
  builder_.add_mob(mob);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_X = 4,
    VT_CHUNK_Z = 6,
    VT_BLOCKS = 8,
    VT_SCHEDULED_UPDATES = 10
  };
  int32_t chunk_x() const {
    return GetField<int32_t>(VT_CHUNK_X, 0);
  }
  int32_t chunk_z() const {
    return GetField<int32_t>(VT_CHUNK_Z, 0);
  }
  const flatbuffers::Vector<uint16_t> *blocks() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_BLOCKS);
  }
  const flatbuffers::Vector<uint32_t> *scheduled_updates() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SCHEDULED_UPDATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHUNK_X) &&
           VerifyField<int32_t>(verifier, VT_CHUNK_Z) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           VerifyOffset(verifier, VT_SCHEDULED_UPDATES) &&
           verifier.VerifyVector(scheduled_updates()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunk_x(int32_t chunk_x) {
    fbb_.AddElement<int32_t>(Chunk::VT_CHUNK_X, chunk_x, 0);
  }
  void add_chunk_z(int32_t chunk_z) {
    fbb_.AddElement<int32_t>(Chunk::VT_CHUNK_Z, chunk_z, 0);
  }
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> blocks) {
    fbb_.AddOffset(Chunk::VT_BLOCKS, blocks);
  }
  void add_scheduled_updates(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> scheduled_updates) {
    fbb_.AddOffset(Chunk::VT_SCHEDULED_UPDATES, scheduled_updates);
  }
  explicit ChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChunkBuilder &operator=(const ChunkBuilder &);
  flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Chunk> CreateChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chunk_x = 0,
    int32_t chunk_z = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> blocks = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> scheduled_updates = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_scheduled_updates(scheduled_updates);
  builder_.add_blocks(blocks);
  builder_.add_chunk_z(chunk_z);
  builder_.add_chunk_x(chunk_x);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chunk> CreateChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chunk_x = 0,
    int32_t chunk_z = 0,
    const std::vector<uint16_t> *blocks = nullptr,
    const std::vector<uint32_t> *scheduled_updates = nullptr) {
  auto blocks__ = blocks ? _fbb.CreateVector<uint16_t>(*blocks) : 0;
  auto scheduled_updates__ = scheduled_updates ? _fbb.CreateVector<uint32_t>(*scheduled_updates) : 0;
  return PixCraft::Serializer::CreateChunk(
      _fbb,
      chunk_x,
      chunk_z,
      blocks__,
      scheduled_updates__);
}

struct World FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNKS = 4,
    VT_MOBS_TYPE = 6,
    VT_MOBS = 8,
    VT_SEED = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<PixCraft::Serializer::Chunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PixCraft::Serializer::Chunk>> *>(VT_CHUNKS);
  }
  const flatbuffers::Vector<uint8_t> *mobs_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MOBS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *mobs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_MOBS);
  }
  uint64_t seed() const {
    return GetField<uint64_t>(VT_SEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           VerifyOffset(verifier, VT_MOBS_TYPE) &&
           verifier.VerifyVector(mobs_type()) &&
           VerifyOffset(verifier, VT_MOBS) &&
           verifier.VerifyVector(mobs()) &&
           VerifyMobVector(verifier, mobs(), mobs_type()) &&
           VerifyField<uint64_t>(verifier, VT_SEED) &&
           verifier.EndTable();
  }
};

struct WorldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PixCraft::Serializer::Chunk>>> chunks) {
    fbb_.AddOffset(World::VT_CHUNKS, chunks);
  }
  void add_mobs_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mobs_type) {
    fbb_.AddOffset(World::VT_MOBS_TYPE, mobs_type);
  }
  void add_mobs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> mobs) {
    fbb_.AddOffset(World::VT_MOBS, mobs);
  }
  void add_seed(uint64_t seed) {
    fbb_.AddElement<uint64_t>(World::VT_SEED, seed, 0);
  }
  explicit WorldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WorldBuilder &operator=(const WorldBuilder &);
  flatbuffers::Offset<World> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<World>(end);
    return o;
  }
};

inline flatbuffers::Offset<World> CreateWorld(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PixCraft::Serializer::Chunk>>> chunks = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mobs_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> mobs = 0,
    uint64_t seed = 0) {
  WorldBuilder builder_(_fbb);
  builder_.add_seed(seed);
  builder_.add_mobs(mobs);
  builder_.add_mobs_type(mobs_type);
  builder_.add_chunks(chunks);
  return builder_.Finish();
}

inline flatbuffers::Offset<World> CreateWorldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PixCraft::Serializer::Chunk>> *chunks = nullptr,
    const std::vector<uint8_t> *mobs_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *mobs = nullptr,
    uint64_t seed = 0) {
  auto chunks__ = chunks ? _fbb.CreateVector<flatbuffers::Offset<PixCraft::Serializer::Chunk>>(*chunks) : 0;
  auto mobs_type__ = mobs_type ? _fbb.CreateVector<uint8_t>(*mobs_type) : 0;
  auto mobs__ = mobs ? _fbb.CreateVector<flatbuffers::Offset<void>>(*mobs) : 0;
  return PixCraft::Serializer::CreateWorld(
      _fbb,
      chunks__,
      mobs_type__,
      mobs__,
      seed);
}

inline bool VerifyMob(flatbuffers::Verifier &verifier, const void *obj, Mob type) {
  switch (type) {
    case Mob_NONE: {
      return true;
    }
    case Mob_Player: {
      auto ptr = reinterpret_cast<const PixCraft::Serializer::Player *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Mob_Slime: {
      auto ptr = reinterpret_cast<const PixCraft::Serializer::Slime *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMobVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMob(
        verifier,  values->Get(i), types->GetEnum<Mob>(i))) {
      return false;
    }
  }
  return true;
}

inline const PixCraft::Serializer::World *GetWorld(const void *buf) {
  return flatbuffers::GetRoot<PixCraft::Serializer::World>(buf);
}

inline const PixCraft::Serializer::World *GetSizePrefixedWorld(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<PixCraft::Serializer::World>(buf);
}

inline bool VerifyWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PixCraft::Serializer::World>(nullptr);
}

inline bool VerifySizePrefixedWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PixCraft::Serializer::World>(nullptr);
}

inline void FinishWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PixCraft::Serializer::World> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PixCraft::Serializer::World> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Serializer
}  // namespace PixCraft

#endif  // FLATBUFFERS_GENERATED_SERIALIZER_PIXCRAFT_SERIALIZER_H_
